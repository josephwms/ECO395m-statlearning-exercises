---
title: 'ECO 395M: StatLearning Exercise 1'
author: "Joseph Williams, Aahil Navroz, Suqian Qi"
date: "`r Sys.Date()`"
output: 
  html_document: default
  md_document:

---

```{r, message=FALSE, echo=FALSE, warning=FALSE}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(class)
library(rsample)
library(caret)
library(glmnet) 
library(pROC)
library(gamlr)
library(mosaic)
library(Metrics)
library(MASS)
```

## Saratoga house prices

Return to the data set on house prices in Saratoga, NY that we considered in class.  Recall that a starter script here is in `saratoga_lm.R`.  For this data set, you'll run a "horse race" (i.e. a model comparison exercise) between two model classes: linear models and KNN.  

- Build the best linear model for price that you can.  It should clearly outperform the "medium" model that we considered in class.  Use any combination of transformations, engineering features, polynomial terms, and interactions that you want; and use any strategy for selecting the model that you want.  
- Now build the best K-nearest-neighbor regression model for price that you can.  Note: you still need to choose which features should go into a KNN model, but you don't explicitly include interactions or polynomial terms.  The method is sufficiently adaptable to find interactions and nonlinearities, if they are there.   But do make sure to _standardize_ your variables before applying KNN, or at least do something that accounts for the large differences in scale across the different variables here.  

Which model seems to do better at achieving lower out-of-sample mean-squared error?   Write a report on your findings as if you were describing your price-modeling strategies for a local taxing authority, who needs to form predicted market values for properties in order to know how much to tax them.  Keep the main focus on the conclusions and model performance; any relevant technical details should be put in an appendix.  

Note: When measuring out-of-sample performance, there is _random variation_ due to the particular choice of data points that end up in your train/test split.  Make sure your script addresses this by averaging the estimate of out-of-sample RMSE over many different random train/test splits, either randomly or by cross-validation.


```{r, message=FALSE, echo=FALSE, warning=FALSE}
# input and standardized the data
data(SaratogaHouses)
data_stand = SaratogaHouses
data_stand = sapply(data_stand, as.numeric)
data_stand = data.frame(data_stand)
data_stand[, -1] = scale(data_stand[, -1])

# Generate polynomial features up to power of 2 with interactions for each variable
predictor = data_stand[,-1]
variables = names(predictor)
squared_terms = paste0("I(", variables, "^2)", collapse = " + ")
formula = as.formula(paste("~ .^2 +", squared_terms))
predictors =  model.matrix(formula, data = predictor)

set.seed(17)

# Fit the data with the medium model and see the average RMSE under CV.
rmse_values = numeric(10)
for (i in 1:10) {
  # Split data into training and testing sets
  train_index = createDataPartition(data_stand$price, p = 0.8, list = FALSE)
  X_train = data_stand[train_index, -1]
  y_train = data_stand[train_index, 1]
  X_test = data_stand[-train_index, -1]
  y_test = data_stand[-train_index, 1]
  
  # Fit linear regression model
  model = lm(y_train ~ ., data = as.data.frame(X_train))
  y_pred = predict(model, newdata = as.data.frame(X_test))
  # Calculate RMSE and store it
  rmse_values[i] = RMSE(y_test, y_pred)
}
linear_rmse = mean(rmse_values)
```

Before fitting data to models, we first standardized all the data except price. Now all variables have same predictive effect on price. We first fit the data with the 'medium' model. The baseline out-of-sample RMSE is 58914.447. Then we tried to introduce the interaction term and square terms. We tried with Lasso and Ridge models.

```{r, message=FALSE, echo=FALSE, warning=FALSE}
# Fit the data using lasso and ridge model
set.seed(17)
lasso_model = cv.glmnet(x = predictors, y = data_stand$price, alpha = 1)
ridge_model = cv.glmnet(x = predictors, y = data_stand$price, alpha = 0)
lasso_rmse_1se = sqrt(lasso_model$cvm[lasso_model$lambda == lasso_model$lambda.1se])
ridge_rmse_1se = sqrt(ridge_model$cvm[ridge_model$lambda == ridge_model$lambda.1se])
```

Under cross-validation and 1se criterion, we chose the Lasso model: price ~ landvalue + livingArea + bathrooms + waterfront + centralAir + waterfront^2 + centralAir^2 + landValue:newConstruction + livingArea:centralAir + bathrooms:centralAir. Ridge suggests that landvalue, livingArea, bathrooms, rooms, centralAir^2 and waterfront:newConstruction are most effective. Both out-of-sample RMSE of Lasso and Ridge don't perform better than the baseline. Thus we considered to manually choose some features.

```{r, message=FALSE, echo=FALSE, warning=FALSE}
set.seed(17)

# Fit the data with the linear model and see the average RMSE under CV.
rmse_values1 = numeric(10)
for (i in 1:10) {
  # Split data into training and testing sets
  train_index = createDataPartition(data_stand$price, p = 0.8, list = FALSE)
  X_train = predictors[train_index, -1]
  y_train = data_stand[train_index, 1]
  X_test = predictors[-train_index, -1]
  y_test = data_stand[-train_index, 1]
  
  # Fit linear regression model
  model = lm(y_train ~ landValue + livingArea + bathrooms + waterfront + centralAir
             + I(waterfront^2) + I(centralAir^2) + landValue:newConstruction + livingArea:centralAir
             + bathrooms:centralAir + bathrooms + rooms + waterfront:newConstruction, data = as.data.frame(X_train))
  y_pred = predict(model, newdata = as.data.frame(X_test))
  # Calculate RMSE and store it
  rmse_values1[i] = RMSE(y_test, y_pred)
}
linear_rmse1 = mean(rmse_values1)

```

We combine the terms appeared in Lasso and Ridge regression and we get a better linear model than the medium one. Then we go with KNN model.

```{r, message=FALSE, echo=FALSE, warning=FALSE}
# KNN Model
set.seed(17)
# Use lasso model to provide feature selection guidance for knn
predictor_matrix = as.matrix(predictor)
lasso_guide = cv.glmnet(x = predictor_matrix, y = data_stand$price, alpha = 1)
coef(lasso_guide, s = "lambda.1se")

run_knnreg_cv = function(data, num_folds) {
  k_values = seq(2, 100, by = 2)  # values of k to be evaluated
  
  # Initialize dataframe to store results
  results_df = data.frame(k = integer(), avg_rmse = numeric())
  
  # Perform cross-validation for each value of k
  for (k in k_values) {
    # Initialize vector to store RMSE values for each fold
    rmse_values = numeric(num_folds)
    # Create indices for cross-validation folds
    folds = sample(rep(1:num_folds, length.out = nrow(data)))
    # Iterate through each fold
    for (fold in 1:num_folds) {
      # Extract training and testing data for this fold
      train_data = data[folds != fold, ]
      test_data = data[folds == fold, ]
      # Perform KNN regression
      model = knnreg(price ~ lotSize + landValue + livingArea + bathrooms + rooms + waterfront
                     + newConstruction + centralAir, data = train_data, k = k)
      # Make predictions
      predictions = predict(model, test_data)
      # Calculate RMSE for this fold
      temp = (predictions - test_data["price"])^2
      rmse_values[fold] = sqrt(mean(temp$price))
    }
    # Calculate average RMSE across all folds
    avg_rmse = mean(rmse_values)
    # Append results to dataframe
    results_df = rbind(results_df, data.frame(k = k, avg_rmse = avg_rmse))
  }
  return(results_df)
}
rmse_result = run_knnreg_cv(data_stand, 10)
ggplot(rmse_result, aes(x = k, y = avg_rmse)) +
  geom_line() + geom_point() +
  ggtitle("Average RMSE vs K") +
  xlab("K") + ylab("RMSE")
optimal_k = rmse_result[which.min(rmse_result$avg_rmse), ]$k
knn_rmse = rmse_result[optimal_k/2,]$avg_rmse
```

For the KNN model, we use lasso model to do the feature selection for us. We assuming that features that are more important in Lasso also make sense in KNN model. We choose lotSize, landValue, livingArea, bathrooms, rooms, waterfront, newConstruction and centralAir to fit the KNN model. Under CV, we choose the optimal k equal to 18. However, KNN model performs worse in out-of-sample RMSE than medium and our newly find model. All the RMSE here are the average RMSE under cross-validation. 

## Classification and retrospective sampling

*Make a bar plot of default probability by credit history, and build a logistic regression model for predicting default probability, using the variables `duration + amount + installment + age + history + purpose + foreign`.*

```{r, message=FALSE, echo=FALSE, warning=FALSE}
germancredit = read.csv('./data/german_credit.csv')
#head(germancredit)

##Make a logistic model for predicting default probability
logit1 = glm(Default ~ duration + amount + installment + age + history + purpose + foreign, data=germancredit, family='binomial')
#coef(logit1) %>% round(2)

#predicting probabilities for each obs.
germancredit$est_prob_default = predict(logit1, germancredit, type='response')

##Bar graph of average predicted default probability by credit history
germancredit %>% group_by(history) %>% 
  summarize(means_byhistory = mean(est_prob_default)) %>%
  ggplot(., aes(x=history, y=means_byhistory, fill=history)) +
  geom_col() +
  ylim(0,.7) +
  labs(title = "Logit-Predicted Probability of Default by History",
       x = "Credit History",
       y = "Mean Default Probability") +
  theme_minimal()

#germancredit %>% group_by(history) %>% summarize(history_count = n()) %>% head()
```

*What do you notice about the `history` variable vis-a-vis predicting defaults?  What do you think is going on here?  In light of what you see here, do you think this data set is appropriate for building a predictive model of defaults, if the purpose of the model is to screen prospective borrowers to classify them into "high" versus "low" probability of default?  Why or why not---and if not, would you recommend any changes to the bank's sampling scheme?*

In this visualization we see higher predicted probabilities of default for individuals with good credit vs those with terrible credit. This counter-intuitive result is likely caused by our dubious sampling method that "matches each default with similar sets of loans that had not defaulted, including all reasonably close matches in the analysis."

The problem here is that we are conditioning on defaulted loans and thus creating a biased sample.  The matching loans associated with `history` == "good" may have other characteristics which are not as often associated with default, and so our model may distiguish `historygood` as the feature which best explains variation in `Default`.  For this reason, this data set is inappropriate for building a model to screen prospective borrowers for default risk.  Random sampling would eliminate this issue because there would be a much larger number of loans with `historygood` == 1 & `Default` == 0, and so other, less-biased relationships might emerge.

```{r, message=FALSE, echo=FALSE, warning=FALSE}

```


```{r, message=FALSE, echo=FALSE, warning=FALSE}

```
## Children and hotel reservations

*The files `hotels_dev.csv` and `hotels_val.csv` contains data on tens of thousands of hotel stays from a major U.S.-based hotel chain.  The goal of this problem is simple: to build a predictive model for whether a hotel booking will have children on it. This is an excellent use case for an ML model: a piece of software that can scan the bookings for the week ahead and produce an estimate for how likely each one is to have a "hidden" child on it.*


```{r, message=FALSE, echo=FALSE, warning=FALSE}
hoteldev = read.csv('./data/hotels_dev.csv')
hotelval = read_csv('./data/hotels_val.csv')
```


### Model building

*Using only the data in `hotels.dev.csv`, please compare the out-of-sample performance of the following models:*

1. baseline 1: a small model that uses only the `market_segment`, `adults`, `customer_type`, and `is_repeated_guest` variables as features.

```{r, message=FALSE, echo=FALSE, warning=FALSE}

#Look up traincontrol
#When measuring out-of-sample performance,average the estimate of out-of-sample RMSE over many different random train/test splits, or using cross-validation.

# hotel_split = initial_split(hoteldev, prop = 0.8)
# hotel_train = training(hotel_split)
# hotel_test = testing(hotel_split)

#base1 = glm(children ~ market_segment + customer_type + is_repeated_guest, data=hotel_train, family='binomial')

#Train and cross validate, same step
base1 = train(
  form = children ~ market_segment + customer_type + is_repeated_guest,
  data = hoteldev,
  trControl = trainControl(method = "cv", number = 10),
  method = "glm",
  family = "binomial"
)

print(paste("base1 RMSE:", base1$results$RMSE %>% round(4)))

# Access coefficients from the model object
print(paste("base1 coefficients:", coef(base1$finalModel) %>% round(2)))

```

2. baseline 2: a big model that uses all the possible predictors _except_ the `arrival_date` variable (main effects only).  


3. the best linear model you can build, including any engineered features that you can think of that improve the performance (interactions, features derived from time stamps, etc).  

Use the `hotels_dev.csv` file for your __entire__ model building and testing pipeline.  That is, you'll create your train/test splits using `hotels_dev` only, and not testing at all on `hotels_val`.  Everything in `hotels_val` should be held back for the next part of this exercise.

Note: you can measure out-of-sample performance in any reasonable way that we've talked about in class or that you've encountered in the reading, as long as you are clear how you're doing it.  


### Model validation: step 1

Once you've built your best model and assessed its out-of-sample performance using `hotels_dev`, now turn to the data in `hotels_val`.  Now you'll __validate__ your model using this entirely fresh subset of the data, i.e. one that wasn't used to fit OR test as part of the model-building stage.  (Using a separate "validation" set, completely apart from your training and testing set, is a generally accepted best practice in machine learning.)  

Produce an ROC curve for your best model, using the data in `hotels_val`: that is, plot TPR(t) versus FPR(t) as you vary the classification threshold t.  


### Model validation: step 2

Next, create 20 folds of `hotels_val`.  There are 4,999 bookings in `hotels_val`, so each fold will have about 250 bookings in it -- roughly the number of bookings the hotel might have on a single busy weekend.  For each fold:  

1. Predict whether each booking will have children on it.  
2. Sum up the predicted probabilities for all the bookings in the fold.  This gives an estimate of the expected number of bookings with children for that fold.  
3. Compare this "expected" number of bookings with children versus the actual number of bookings with children in that fold.

How well does your model do at predicting the total number of bookings with children in a group of 250 bookings?  Summarize this performance across all 20 folds of the `val` set in an appropriate figure or table.  

```{r, message=FALSE, echo=FALSE, warning=FALSE}

```

## Mushroom classification

The data in [mushrooms.csv](../data/mushrooms.csv) correspond to 23 species of gilled mushrooms in the Agaricus and Lepiota Family.  Each species is identified as definitely edible (class = e), definitely poisonous (class = p), or of unknown edibility and not recommended.  (This latter class was combined with the poisonous one.)  There is no simple rule for determining the edibility of a mushroom, analogous to "leaves of three, let it be" for poison ivy.  

The features in the data set are as follows:

| Attribute Name               | Description                                                                 |
|------------------------------|-----------------------------------------------------------------------------|
| cap-shape                    | bell=b, conical=c, convex=x, flat=f, knobbed=k, sunken=s                    |
| cap-surface                  | fibrous=f, grooves=g, scaly=y, smooth=s                                     |
| cap-color                    | brown=n, buff=b, cinnamon=c, gray=g, green=r, pink=p, purple=u, red=e, white=w, yellow=y |
| bruises                      | bruises=t, no=f                                                             |
| odor                         | almond=a, anise=l, creosote=c, fishy=y, foul=f, musty=m, none=n, pungent=p, spicy=s |
| gill-attachment              | attached=a, descending=d, free=f, notched=n                                 |
| gill-spacing                 | close=c, crowded=w, distant=d                                               |
| gill-size                    | broad=b, narrow=n                                                           |
| gill-color                   | black=k, brown=n, buff=b, chocolate=h, gray=g, green=r, orange=o, pink=p, purple=u, red=e, white=w, yellow=y |
| stalk-shape                  | enlarging=e, tapering=t                                                     |
| stalk-root                   | bulbous=b, club=c, cup=u, equal=e, rhizomorphs=z, rooted=r, missing=?       |
| stalk-surface-above-ring     | fibrous=f, scaly=y, silky=k, smooth=s                                       |
| stalk-surface-below-ring     | fibrous=f, scaly=y, silky=k, smooth=s                                       |
| stalk-color-above-ring       | brown=n, buff=b, cinnamon=c, gray=g, orange=o, pink=p, red=e, white=w, yellow=y |
| stalk-color-below-ring       | brown=n, buff=b, cinnamon=c, gray=g, orange=o, pink=p, red=e, white=w, yellow=y |
| veil-type                    | partial=p, universal=u                                                      |
| veil-color                   | brown=n, orange=o, white=w, yellow=y                                        |
| ring-number                  | none=n, one=o, two=t                                                        |
| ring-type                    | cobwebby=c, evanescent=e, flaring=f, large=l, none=n, pendant=p, sheathing=s, zone=z |
| spore-print-color            | black=k, brown=n, buff=b, chocolate=h, green=r, orange=o, purple=u, white=w, yellow=y |
| population                   | abundant=a, clustered=c, numerous=n, scattered=s, several=v, solitary=y     |
| habitat                      | grasses=g, leaves=l, meadows=m, paths=p, urban=u, waste=w, woods=d          |


So you can see that all of the variables are categorical, sometimes with more than 2 levels.

Can you predict whether a mushroom is poisonous using machine learning?  Write a short report on the best-performing model you can find using lasso-penalized logistic regression.  Evaluate the out-of-sample performance of your model using a ROC curve.  Based on this ROC curve, recommend a probability threshold for declaring a mushroom poisonous.  How well does your model perform at this threshold, as measured by false positive rate and true positive rate?  

```{r, message=FALSE, echo=FALSE, warning=FALSE}

# Load the mushroom dataset
mushrooms = read.csv("./data/mushrooms.csv")

# Removing columns that would have factors with less than 2 levels
mushrooms = mushrooms[sapply(mushrooms, function(x) length(unique(x)) > 1)]

# Convert all categorical variables to factors
mushrooms = mushrooms %>% mutate_if(is.character, as.factor)

# Encode the target variable 'class' as binary
mushrooms$class = as.numeric(mushrooms$class) - 1

# Create a training and test dataset
set.seed(42) # For reproducibility
training_index = createDataPartition(mushrooms$class, p = 0.8, list = FALSE)
train_data = mushrooms[training_index, ]
test_data = mushrooms[-training_index, ]

# Prepare the model matrix
x_train = model.matrix(class ~ . - 1, data = train_data) # -1 to exclude intercept
y_train = train_data$class

x_test = model.matrix(class ~ . - 1, data = test_data)
y_test = test_data$class

# Fit the lasso-penalized logistic regression model
cv_fit = cv.glmnet(x_train, y_train, family = "binomial", alpha = 1)

plot(cv_fit)

# Print the minimum lambda value used
print(cv_fit$lambda.min)

# Using the lasso-penalized logistic regression model, we get the graph depicted above showing the relationship between log lambda and binomial deviance. The lambda that minimizes deviance is approximately 0.0001444448. We can use this value to evaluate the out-of-sample performance of your model through a ROC curve. 

# Predict on the test set
# Here we extract the probabilities for the class of interest (which is the second column of the predict matrix)
predictions = predict(cv_fit, newx = x_test, s = "lambda.min", type = "response")[,1]

# Generate the ROC curve
roc_result = roc(response = y_test, predictor = predictions)
plot(roc_result, main = "ROC Curve")

# The ROC curve in this case is not exactly a curve but rather 2 perpendicular lines that intersect at (1,1). This means that the is high sensitivity and high specificity and thus is effective at distinguishing between the two classes (poisonous and non-poisonous mushrooms).

# Find the optimal threshold
coords(roc_result, "best", ret = c("threshold", "sensitivity", "specificity"))



best_coords = coords(roc_result, "best", ret = c("specificity", "sensitivity"))
fpr = 1 - best_coords["specificity"]
tpr = best_coords["sensitivity"]

list(FPR = fpr, TPR = tpr)

# Based on the ROC curve I would recommend a probability threshold of 0.5017094. Since our false positive rate of 0 and a true positive of 1, it is safe to say that our model performs exceptionally well at this threshold. 

```
