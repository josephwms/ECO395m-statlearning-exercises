---
title: 'ECO 395M: StatLearning Exercise 1'
author: "Joseph Williams, Aahil Navroz, Suqian Qi"
date: "`r Sys.Date()`"
output: 
  html_document: default
  md_document:

---

```{r, message=FALSE, echo=FALSE, warning=FALSE}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(class)
library(rsample)
library(caret)
library(glmnet)
library(gamlr)
library(pROC)
```

## Saratoga house prices

Return to the data set on house prices in Saratoga, NY that we considered in class.  Recall that a starter script here is in `saratoga_lm.R`.  For this data set, you'll run a "horse race" (i.e. a model comparison exercise) between two model classes: linear models and KNN.  

- Build the best linear model for price that you can.  It should clearly outperform the "medium" model that we considered in class.  Use any combination of transformations, engineering features, polynomial terms, and interactions that you want; and use any strategy for selecting the model that you want.  
- Now build the best K-nearest-neighbor regression model for price that you can.  Note: you still need to choose which features should go into a KNN model, but you don't explicitly include interactions or polynomial terms.  The method is sufficiently adaptable to find interactions and nonlinearities, if they are there.   But do make sure to _standardize_ your variables before applying KNN, or at least do something that accounts for the large differences in scale across the different variables here.  

Which model seems to do better at achieving lower out-of-sample mean-squared error?   Write a report on your findings as if you were describing your price-modeling strategies for a local taxing authority, who needs to form predicted market values for properties in order to know how much to tax them.  Keep the main focus on the conclusions and model performance; any relevant technical details should be put in an appendix.  

Note: When measuring out-of-sample performance, there is _random variation_ due to the particular choice of data points that end up in your train/test split.  Make sure your script addresses this by averaging the estimate of out-of-sample RMSE over many different random train/test splits, either randomly or by cross-validation.


```{r, message=FALSE, echo=FALSE, warning=FALSE}



```

## Classification and retrospective sampling

*Make a bar plot of default probability by credit history, and build a logistic regression model for predicting default probability, using the variables `duration + amount + installment + age + history + purpose + foreign`.*

```{r, message=FALSE, echo=FALSE, warning=FALSE}
germancredit = read.csv('./data/german_credit.csv')
#head(germancredit)

##Make a logistic model for predicting default probability
logit1 = glm(Default ~ duration + amount + installment + age + history + purpose + foreign, data=germancredit, family='binomial')
#coef(logit1) %>% round(2)

#predicting probabilities for each obs.
germancredit$est_prob_default = predict(logit1, germancredit, type='response')

##Bar graph of average predicted default probability by credit history
germancredit %>% group_by(history) %>% 
  summarize(means_byhistory = mean(est_prob_default)) %>%
  ggplot(., aes(x=history, y=means_byhistory, fill=history)) +
  geom_col() +
  ylim(0,.7) +
  labs(title = "Logit-Predicted Probability of Default by History",
       x = "Credit History",
       y = "Mean Default Probability") +
  theme_minimal()

#germancredit %>% group_by(history) %>% summarize(history_count = n()) %>% head()
```

*What do you notice about the `history` variable vis-a-vis predicting defaults?  What do you think is going on here?  In light of what you see here, do you think this data set is appropriate for building a predictive model of defaults, if the purpose of the model is to screen prospective borrowers to classify them into "high" versus "low" probability of default?  Why or why not---and if not, would you recommend any changes to the bank's sampling scheme?*

In this visualization we see higher predicted probabilities of default for individuals with good credit vs those with terrible credit. This counter-intuitive result is likely caused by our dubious sampling method that "matches each default with similar sets of loans that had not defaulted, including all reasonably close matches in the analysis."

The problem here is that we are conditioning on defaulted loans and thus creating a biased sample.  The matching loans associated with `history` == "good" may have other characteristics which are not as often associated with default, and so our model may distiguish `historygood` as the feature which best explains variation in `Default`.  For this reason, this data set is inappropriate for building a model to screen prospective borrowers for default risk.  Random sampling would eliminate this issue because there would be a much larger number of loans with `historygood` == 1 & `Default` == 0, and so other, less-biased relationships might emerge.

```{r, message=FALSE, echo=FALSE, warning=FALSE}

```


```{r, message=FALSE, echo=FALSE, warning=FALSE}

```
## Children and hotel reservations

*The files `hotels_dev.csv` and `hotels_val.csv` contains data on tens of thousands of hotel stays from a major U.S.-based hotel chain.  The goal of this problem is simple: to build a predictive model for whether a hotel booking will have children on it. This is an excellent use case for an ML model: a piece of software that can scan the bookings for the week ahead and produce an estimate for how likely each one is to have a "hidden" child on it.*


```{r, message=FALSE, echo=FALSE, warning=FALSE}
hoteldev = read.csv('./data/hotels_dev.csv')
hotelval = read.csv('./data/hotels_val.csv')
```


### Model building

*Using only the data in `hotels.dev.csv`, please compare the out-of-sample performance of the following models:*

1. baseline 1: a small model that uses only the `market_segment`, `adults`, `customer_type`, and `is_repeated_guest` variables as features.

```{r, message=FALSE, echo=FALSE, warning=FALSE}

#Look up traincontrol
#When measuring out-of-sample performance,average the estimate of out-of-sample RMSE over many different random train/test splits, or using cross-validation.

# hotel_split = initial_split(hoteldev, prop = 0.8)
# hotel_train = training(hotel_split)
# hotel_test = testing(hotel_split)

#base1 = glm(children ~ market_segment + customer_type + is_repeated_guest, data=hotel_train, family='binomial')

#Train and cross validate, same step
base1 = train(
  form = children ~ market_segment + customer_type + is_repeated_guest,
  data = hoteldev,
  trControl = trainControl(method = "cv", number = 10),
  method = "glm",
  family = "binomial"
)

# Access coefficients from the model object
cat('base1 coefficients:')
print(coef(base1$finalModel) %>% round(2))

cat(paste('base1 RMSE:', base1$results$RMSE %>% round(4)))
```

2. baseline 2: a big model that uses all the possible predictors _except_ the `arrival_date` variable (main effects only).  

```{r, message=FALSE, echo=FALSE, warning=FALSE}

#Train and cross validate, same step
base2 = train(
  form = children ~ . - arrival_date,
  data = hoteldev,
  trControl = trainControl(method = "cv", number = 10),
  method = "glm",
  family = "binomial"
)

# Access coefficients from the model object
cat('base2 coefficients (first 10):')
print(coef(base2$finalModel)[1:10] %>% round(2))

cat(paste('base2 RMSE:', base2$results$RMSE %>% round(4)))
```

3. the best linear model you can build, including any engineered features that you can think of that improve the performance (interactions, features derived from time stamps, etc).

```{r, message=FALSE, echo=FALSE, warning=FALSE, results='hide'}
base3x = model.matrix(children ~ .-1 - arrival_date, data=hoteldev) # do -1 to drop intercept!
base3y = hoteldev$children

#first eliminate year from arrival_date
#hoteldev$arrival_date <- substr(hoteldev$arrival_date, 6, 10)

set.seed(187)
base3 = cv.gamlr(base3x, base3y, nfold=10, family="binomial", verb=TRUE)

base3.min = coef(base3, select='min') #this is the minimized lasso
base3.1se = coef(base3) #we want the simpler model
cat(paste("base3 is a lasso with lambda =", log(base3$lambda.1se) %>% round(4), " and a total of", sum(base3.1se!=0), "coefficients"))
print()
cat(paste('base3 RMSE:', sqrt(base3$cvm[base3$seg.1se]) %>% round(4)))


```

```{r, message=FALSE, echo=FALSE, warning=FALSE}


```


Use the `hotels_dev.csv` file for your __entire__ model building and testing pipeline.  That is, you'll create your train/test splits using `hotels_dev` only, and not testing at all on `hotels_val`.  Everything in `hotels_val` should be held back for the next part of this exercise.

Note: you can measure out-of-sample performance in any reasonable way that we've talked about in class or that you've encountered in the reading, as long as you are clear how you're doing it.  


### Model validation: step 1

Once you've built your best model and assessed its out-of-sample performance using `hotels_dev`, now turn to the data in `hotels_val`.  Now you'll __validate__ your model using this entirely fresh subset of the data, i.e. one that wasn't used to fit OR test as part of the model-building stage.  (Using a separate "validation" set, completely apart from your training and testing set, is a generally accepted best practice in machine learning.)  

Produce an ROC curve for your best model, using the data in `hotels_val`: that is, plot TPR(t) versus FPR(t) as you vary the classification threshold t.  


### Model validation: step 2

Next, create 20 folds of `hotels_val`.  There are 4,999 bookings in `hotels_val`, so each fold will have about 250 bookings in it -- roughly the number of bookings the hotel might have on a single busy weekend.  For each fold:  

1. Predict whether each booking will have children on it.  
2. Sum up the predicted probabilities for all the bookings in the fold.  This gives an estimate of the expected number of bookings with children for that fold.  
3. Compare this "expected" number of bookings with children versus the actual number of bookings with children in that fold.

How well does your model do at predicting the total number of bookings with children in a group of 250 bookings?  Summarize this performance across all 20 folds of the `val` set in an appropriate figure or table.  

```{r, message=FALSE, echo=FALSE, warning=FALSE}

```

## Mushroom classification

*The data in [mushrooms.csv](../data/mushrooms.csv) correspond to 23 species of gilled mushrooms in the Agaricus and Lepiota Family.  Each species is identified as definitely edible (class = e), definitely poisonous (class = p), or of unknown edibility and not recommended.  (This latter class was combined with the poisonous one.)  There is no simple rule for determining the edibility of a mushroom, analogous to "leaves of three, let it be" for poison ivy.*

*The features in the data set are as follows [see assignment]*

*So you can see that all of the variables are categorical, sometimes with more than 2 levels.*

*Can you predict whether a mushroom is poisonous using machine learning?  Write a short report on the best-performing model you can find using lasso-penalized logistic regression.  Evaluate the out-of-sample performance of your model using a ROC curve.  Based on this ROC curve, recommend a probability threshold for declaring a mushroom poisonous.  How well does your model perform at this threshold, as measured by false positive rate and true positive rate?*


```{r, message=FALSE, echo=FALSE, warning=FALSE}

# Load the mushroom dataset
mushrooms = read.csv("./data/mushrooms.csv")

# Removing columns that would have factors with less than 2 levels
mushrooms = mushrooms[sapply(mushrooms, function(x) length(unique(x)) > 1)]

# Convert all categorical variables to factors
mushrooms = mushrooms %>% mutate_if(is.character, as.factor)

# Encode the target variable 'class' as binary
mushrooms$class = as.numeric(mushrooms$class) - 1

# Create a training and test dataset
set.seed(42) # For reproducibility
training_index = createDataPartition(mushrooms$class, p = 0.8, list = FALSE)
train_data = mushrooms[training_index, ]
test_data = mushrooms[-training_index, ]

# Prepare the model matrix
x_train = model.matrix(class ~ . - 1, data = train_data) # -1 to exclude intercept
y_train = train_data$class

x_test = model.matrix(class ~ . - 1, data = test_data)
y_test = test_data$class

# Fit the lasso-penalized logistic regression model
cv_fit = cv.glmnet(x_train, y_train, family = "binomial", alpha = 1)

plot(cv_fit)

# Print the minimum lambda value used
print(cv_fit$lambda.min)

# Predict on the test set
# Here we extract the probabilities for the class of interest (which is the second column of the predict matrix)
predictions = predict(cv_fit, newx = x_test, s = "lambda.min", type = "response")[,1]

# Generate the ROC curve
roc_result = roc(response = y_test, predictor = predictions)
plot(roc_result, main = "ROC Curve")

# Find the optimal threshold
coords(roc_result, "best", ret = c("threshold", "sensitivity", "specificity"))

# Use the optimal threshold to predict whether a mushroom is poisonous
optimal_threshold = coords(roc_result, "best", ret = "threshold")
predicted_classes = ifelse(predictions > optimal_threshold, 1, 0)

optimal_threshold

best_coords = coords(roc_result, "best", ret = c("specificity", "sensitivity"))
fpr = 1 - best_coords["specificity"]
tpr = best_coords["sensitivity"]

list(FPR = fpr, TPR = tpr)

```










